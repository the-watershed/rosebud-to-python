class ChatManager {
    constructor(characterDescription) {
        this.characterDescription = characterDescription;
        this.messages = [];
    }

    addMessage(role, content) {
        this.messages.push({ role, content });
    }

    async getCharacterResponse() {
        return "Character response placeholder";
    }
}

class Item {
    constructor(name, type, effect) {
        this.name = name;
        this.type = type;
        this.effect = effect;
    }
}

class Ability {
    constructor(name, type, effect, cooldown) {
        this.name = name;
        this.type = type;
        this.effect = effect;
        this.cooldown = cooldown;
        this.lastUsed = 0;
    }

    use(user, target) {
        const currentTime = user.scene.time.now;
        if (currentTime - this.lastUsed >= this.cooldown) {
            this.effect(user, target);
            this.lastUsed = currentTime;
            return true;
        }
        return false;
    }
}

class Inventory {
    constructor(capacity) {
        this.items = [];
        this.capacity = capacity;
        this.equipped = {
            weapon: null,
            armor: null
        };
    }

    addItem(item) {
        if (this.items.length < this.capacity) {
            this.items.push(item);
            return true;
        }
        return false;
    }

    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index > -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }

    useItem(item, target) {
        if (this.removeItem(item)) {
            item.effect(target);
            return true;
        }
        return false;
    }

    equipItem(item) {
        if (item.type === 'weapon') {
            if (this.equipped.weapon) {
                this.items.push(this.equipped.weapon);
            }
            this.equipped.weapon = item;
        } else if (item.type === 'armor') {
            if (this.equipped.armor) {
                this.items.push(this.equipped.armor);
            }
            this.equipped.armor = item;
        }
        this.removeItem(item);
    }
}

class LightSource {
    constructor(scene, x, y, radius) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
}

class Entity {
    constructor(scene, x, y, char, color = '#ffffff') {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.char = char;
        this.color = color;
        this.lastMoveTime = 0;
        this.stats = {
            hp: 100,
            maxHp: 100,
            mp: 50,
            maxMp: 50,
            strength: 10,
            dexterity: 10,
            intelligence: 10,
            level: 1,
            movementRate: 1
        };
        this.inventory = new Inventory(10);
        this.abilities = [];
        this.spells = [];
        this.layer = 2; // Default layer for entities
        this.lightSource = null;
    }

    render() {
        this.text = this.scene.add.text(this.x * 20, this.y * 20, this.char, {
            font: '20px monospace',
            fill: this.color
        });
        this.scene.addToLayer(this.text, this.layer);
        console.log(`Rendered entity at (${this.x}, ${this.y}) with char ${this.char}`);
    }

    move(dx, dy) {
        const currentTime = this.scene.time.now;
        if (currentTime - this.lastMoveTime >= 500) {
            const newX = this.x + dx;
            const newY = this.y + dy;
            if (this.scene.isWalkable(newX, newY)) {
                this.x = newX;
                this.y = newY;
                this.text.setPosition(this.x * 20, this.y * 20);
                this.lastMoveTime = currentTime;
                if (this.lightSource) {
                    this.lightSource.x = this.x;
                    this.lightSource.y = this.y;
                }
                this.scene.updateLineOfSight();
            }
        }
    }

    takeDamage(amount) {
        this.stats.hp = Math.max(0, this.stats.hp - amount);
        if (this.stats.hp === 0) {
            this.die();
        }
    }

    die() {
        if (this instanceof Monster) {
            this.scene.dropTreasure(this.x, this.y);
            this.scene.monsters = this.scene.monsters.filter(m => m !== this);
        }
        this.scene.removeFromLayer(this.text, this.layer);
        this.text.destroy();
    }

    useAbility(abilityName, target) {
        const ability = this.abilities.find(a => a.name === abilityName);
        if (ability) {
            return ability.use(this, target);
        }
        return false;
    }

    castSpell(spellName, target) {
        const spell = this.spells.find(s => s.name === spellName);
        if (spell && this.stats.mp >= spell.cost) {
            this.stats.mp -= spell.cost;
            return spell.use(this, target);
        }
        return false;
    }
}

class Player extends Entity {
    constructor(scene, x, y) {
        super(scene, x, y, '@', '#00ff00');  // Set player color to green
        this.stats.hp = 150;
        this.stats.maxHp = 150;
        this.stats.mp = 100;
        this.stats.maxMp = 100;
        this.weapon = new Item("Sword", "weapon", target => target.takeDamage(10));
        this.armor = new Item("Leather Armor", "armor", wearer => wearer.stats.defense += 5);
        this.inventory.addItem(new Item("Health Potion", "consumable", user => user.stats.hp = Math.min(user.stats.maxHp, user.stats.hp + 50)));
        this.abilities.push(new Ability("Slash", "physical", (user, target) => target.takeDamage(user.stats.strength * 1.5), 2000));
        this.spells.push(new Ability("Fireball", "magical", (user, target) => target.takeDamage(user.stats.intelligence * 2), 5000));
        this.layer = 7; // Player on the new Player layer
        this.lightSource = new LightSource(scene, x, y, 4);
    }

    get attackRating() {
        return this.stats.strength + (this.weapon ? this.weapon.effect.damage : 0);
    }

    get defenseRating() {
        return this.stats.dexterity + (this.armor ? this.armor.effect.defense : 0);
    }
}

class Monster extends Entity {
    constructor(scene, x, y, level) {
        super(scene, x, y, '.');
        this.stats.level = level;
        this.updateStats();
        this.updateChar();
        this.abilities.push(new Ability("Bite", "physical", (user, target) => target.takeDamage(user.stats.strength), 3000));
        this.layer = 2; // Monsters on the Entities layer
    }

    updateStats() {
        const levelFactor = this.stats.level - 1;
        this.stats.hp = this.stats.maxHp = 50 + levelFactor * 10;
        this.stats.strength = 5 + levelFactor * 2;
        this.stats.dexterity = 5 + levelFactor * 2;
        this.stats.intelligence = 5 + levelFactor * 2;
        this.stats.movementRate = 1 + Math.floor(levelFactor / 3);
    }

    updateChar() {
        const levelDiff = this.stats.level - this.scene.player.stats.level;
        if (levelDiff < -1) this.char = '.';
        else if (levelDiff === -1) this.char = 'o';
        else if (levelDiff === 0) this.char = 'O';
        else if (levelDiff === 1) this.char = 'x';
        else if (levelDiff === 2) this.char = 'X';
        else this.char = '#';
        if (this.text) this.text.setText(this.char);
    }

    moveTowardsPlayer() {
        const dx = this.scene.player.x - this.x;
        const dy = this.scene.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= this.stats.movementRate) {
            this.move(dx, dy);
        } else {
            const ratio = this.stats.movementRate / distance;
            this.move(Math.round(dx * ratio), Math.round(dy * ratio));
        }
    }
}

class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.mapWidth = 40;
        this.mapHeight = 25;
        this.inCombat = false;
        this.monsters = [];
        this.debugMode = true;  // Enable debug mode
        this.layers = []; // Array to store layers
        this.layerNames = ['Background', 'Walls', 'Entities', 'Lighting', 'StaticObjects', 'UI', 'Debug', 'Player'];
        this.layerVisibility = [true, true, true, true, true, true, true, true];
        this.torches = [];
    }

    create() {
        console.log("GameScene create method started");
        this.initializeLayers();
        this.generateMap();
        this.spawnPlayer();
        this.monsters = [];
        for (let i = 0; i < 10; i++) {
            this.addRandomMonster();
        }

        this.cursors = this.input.keyboard.createCursorKeys();

        this.chatDialogs = new Map();

        this.createUI();

        this.time.addEvent({
            delay: 2000,
            callback: this.monsterHeartbeat,
            callbackScope: this,
            loop: true
        });

        // Debug text
        this.debugText = this.add.text(10, 10, '', { font: '16px Arial', fill: '#ffffff' });
        this.addToLayer(this.debugText, 6);

        // Test rendering
        this.testRendering();

        // Layer visibility toggles
        this.createLayerToggles();

        this.updateLineOfSight();

        console.log("GameScene create method completed");
    }

    initializeLayers() {
        console.log("Initializing layers");
        for (let i = 0; i < this.layerNames.length; i++) {
            this.layers[i] = this.add.layer();
            this.layers[i].setVisible(this.layerVisibility[i]);
            console.log(`Layer ${i} (${this.layerNames[i]}) created and set visible: ${this.layerVisibility[i]}`);
        }
    }

    addToLayer(gameObject, layerIndex) {
        if (this.layers[layerIndex]) {
            this.layers[layerIndex].add(gameObject);
            console.log(`Added object to layer ${layerIndex} (${this.layerNames[layerIndex]})`);
        } else {
            console.error(`Layer ${layerIndex} does not exist`);
        }
    }

    removeFromLayer(gameObject, layerIndex) {
        if (this.layers[layerIndex]) {
            this.layers[layerIndex].remove(gameObject);
        } else {
            console.error(`Layer ${layerIndex} does not exist`);
        }
    }

    generateMap() {
        console.log("Generating map");
        this.map = [];
        for (let y = 0; y < this.mapHeight; y++) {
            let row = [];
            for (let x = 0; x < this.mapWidth; x++) {
                row.push(' '); // Changed from '#' to ' ' to make the area behind walls blank
            }
            this.map.push(row);
        }

        // Generate rooms
        const rooms = [];
        for (let i = 0; i < 5; i++) {
            const room = this.generateRoom();
            rooms.push(room);
            this.placeRoom(room);
        }

        // Connect rooms with hallways
        for (let i = 0; i < rooms.length - 1; i++) {
            this.connectRooms(rooms[i], rooms[i + 1]);
        }

        // Place walls around hallways
        this.placeWallsAroundHallways();

        // Add torches to rooms
        rooms.forEach(room => {
            if (Math.random() < 0.5) {
                this.placeTorch(room);
            }
        });

        this.updateMapDisplay();
    }

    generateRoom() {
        const width = Phaser.Math.Between(4, 8);
        const height = Phaser.Math.Between(4, 8);
        const x = Phaser.Math.Between(1, this.mapWidth - width - 1);
        const y = Phaser.Math.Between(1, this.mapHeight - height - 1);
        return { x, y, width, height };
    }

    placeRoom(room) {
        for (let y = room.y; y < room.y + room.height; y++) {
            for (let x = room.x; x < room.x + room.width; x++) {
                if (y === room.y || y === room.y + room.height - 1 || x === room.x || x === room.x + room.width - 1) {
                    this.map[y][x] = '#';
                } else {
                    this.map[y][x] = '.';
                }
            }
        }
    }

    connectRooms(room1, room2) {
        let x1 = Phaser.Math.Between(room1.x + 1, room1.x + room1.width - 2);
        let y1 = Phaser.Math.Between(room1.y + 1, room1.y + room1.height - 2);
        let x2 = Phaser.Math.Between(room2.x + 1, room2.x + room2.width - 2);
        let y2 = Phaser.Math.Between(room2.y + 1, room2.y + room2.height - 2);

        while (x1 !== x2 || y1 !== y2) {
            if (x1 !== x2) {
                x1 += x1 < x2 ? 1 : -1;
            } else if (y1 !== y2) {
                y1 += y1 < y2 ? 1 : -1;
            }
            if (this.map[y1][x1] === '#') {
                this.map[y1][x1] = '+'; // Door
            } else {
                this.map[y1][x1] = '.';
            }
        }
    }

    placeWallsAroundHallways() {
        for (let y = 1; y < this.mapHeight - 1; y++) {
            for (let x =

 1; x < this.mapWidth - 1; x++) {
                if (this.map[y][x] === '.') {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (this.map[y + dy][x + dx] === ' ') {
                                this.map[y + dy][x + dx] = '#';
                            }
                        }
                    }
                }
            }
        }
    }

    placeTorch(room) {
        const x = Phaser.Math.Between(room.x + 1, room.x + room.width - 2);
        const y = Phaser.Math.Between(room.y + 1, room.y + room.height - 2);
        this.map[y][x] = 'T';
        const torch = new LightSource(this, x, y, 3);
        this.torches.push(torch);
    }

    updateMapDisplay() {
        console.log("Updating map display");
        for (let y = 0; y < this.mapHeight; y++) {
            for (let x = 0; x < this.mapWidth; x++) {
                const char = this.map[y][x];
                if (char === '#' || char === '+' || char === '.' || char === 'T') {
                    const text = this.add.text(x * 20, y * 20, char, {
                        font: '20px monospace',
                        fill: char === '#' ? '#ffffff' : (char === '+' ? '#8B4513' : (char === 'T' ? '#FFD700' : '#666666'))
                    });
                    this.addToLayer(text, 1); // Add walls, doors, floor, and torches to the Walls layer
                }
            }
        }
    }

    spawnPlayer() {
        console.log("Spawning player");
        let x, y;
        do {
            x = Phaser.Math.Between(1, this.mapWidth - 2);
            y = Phaser.Math.Between(1, this.mapHeight - 2);
        } while (!this.isWalkable(x, y));

        this.player = new Player(this, x, y);
        this.player.render();
        console.log(`Player spawned at (${x}, ${y})`);
    }

    addRandomMonster() {
        let x, y;
        do {
            x = Phaser.Math.Between(1, this.mapWidth - 2);
            y = Phaser.Math.Between(1, this.mapHeight - 2);
        } while (!this.isWalkable(x, y));

        const level = Phaser.Math.Between(this.player.stats.level - 2, this.player.stats.level + 3);
        const monster = new Monster(this, x, y, level);
        monster.render();
        this.monsters.push(monster);
        console.log(`Monster spawned at (${x}, ${y}) with level ${level}`);
    }

    isWalkable(x, y) {
        return (this.map[y][x] === '.' || this.map[y][x] === '+') && 
               (this.layerVisibility[2] ? !this.monsters.some(m => m.x === x && m.y === y) : true);
    }

    update(time) {
        if (!this.inCombat) {
            if (this.cursors.left.isDown) {
                this.player.move(-1, 0);
            } else if (this.cursors.right.isDown) {
                this.player.move(1, 0);
            } else if (this.cursors.up.isDown) {
                this.player.move(0, -1);
            } else if (this.cursors.down.isDown) {
                this.player.move(0, 1);
            }

            this.checkCombat();
        }

        // Update monsters
        if (this.monsters && Array.isArray(this.monsters)) {
            this.monsters.forEach(monster => monster.updateChar());
        }

        // Update UI
        this.updateUI();

        // Update debug information
        this.updateDebugInfo();
    }

    monsterHeartbeat() {
        if (!this.inCombat && this.monsters && Array.isArray(this.monsters) && this.layerVisibility[2]) {
            this.monsters.forEach(monster => monster.moveTowardsPlayer());
        }
    }

    checkCombat() {
        if (this.monsters && Array.isArray(this.monsters) && this.layerVisibility[2]) {
            const adjacentMonster = this.monsters.find(monster => 
                Math.abs(monster.x - this.player.x) <= 1 && 
                Math.abs(monster.y - this.player.y) <= 1
            );

            if (adjacentMonster) {
                this.inCombat = true;
                this.currentMonster = adjacentMonster;
                this.initiateCombat();
            }
        }
    }

    initiateCombat() {
        console.log("Combat initiated!");
        this.combatTurn();
    }

    combatTurn() {
        // Player's turn
        const hitRoll = Phaser.Math.Between(1, 20);
        const hitTarget = 10 + this.currentMonster.stats.dexterity;

        if (hitRoll >= hitTarget) {
            const damage = this.player.attackRating;
            this.currentMonster.takeDamage(damage);
            console.log(`Player hit! Dealt ${damage} damage.`);
        } else {
            console.log("Player missed!");
        }

        if (this.currentMonster.stats.hp > 0) {
            // Monster's turn
            const monsterHitRoll = Phaser.Math.Between(1, 20);
            const playerHitTarget = 10 + this.player.stats.dexterity;

            if (monsterHitRoll >= playerHitTarget) {
                const monsterDamage = this.currentMonster.stats.strength;
                this.player.takeDamage(monsterDamage);
                console.log(`Monster hit! Dealt ${monsterDamage} damage.`);
            } else {
                console.log("Monster missed!");
            }

            // Continue combat
            this.time.delayedCall(1000, this.combatTurn, [], this);
        } else {
            console.log("Monster defeated!");
            this.endCombat();
        }
    }

    endCombat() {
        this.inCombat = false;
        this.currentMonster = null;
    }

    dropTreasure(x, y) {
        this.map[y][x] = '&';
        const treasureText = this.add.text(x * 20, y * 20, '&', {
            font: '20px monospace',
            fill: '#FFD700'  // Set treasure color to gold
        });
        this.addToLayer(treasureText, 4);  // Treasure on StaticObjects layer
    }

    createUI() {
        console.log("Creating UI");
        this.uiText = this.add.text(810, 10, '', { 
            font: '16px monospace', 
            fill: '#ffffff', 
            wordWrap: { width: 280 } 
        });
        this.addToLayer(this.uiText, 5);  // UI layer
        this.updateUI();
    }

    updateUI() {
        if (!this.player) return;

        const player = this.player;
        let inventoryText = 'Inventory:\n';
        if (player.inventory && Array.isArray(player.inventory.items)) {
            player.inventory.items.forEach(item => {
                inventoryText += `- ${item.name}\n`;
            });
        }

        let equippedText = 'Equipped:\n';
        if (player.inventory.equipped.weapon) equippedText += `Weapon: ${player.inventory.equipped.weapon.name}\n`;
        if (player.inventory.equipped.armor) equippedText += `Armor: ${player.inventory.equipped.armor.name}\n`;

        let abilitiesText = 'Abilities:\n';
        if (Array.isArray(player.abilities)) {
            player.abilities.forEach(ability => {
                abilitiesText += `- ${ability.name}\n`;
            });
        }

        let spellsText = 'Spells:\n';
        if (Array.isArray(player.spells)) {
            player.spells.forEach(spell => {
                spellsText += `- ${spell.name}\n`;
            });
        }

        this.uiText.setText(
            `HP: ${player.stats.hp}/${player.stats.maxHp}\n` +
            `MP: ${player.stats.mp}/${player.stats.maxMp}\n` +
            `Level: ${player.stats.level}\n` +
            `Strength: ${player.stats.strength}\n` +
            `Dexterity: ${player.stats.dexterity}\n` +
            `Intelligence: ${player.stats.intelligence}\n` +
            `Attack: ${player.attackRating}\n` +
            `Defense: ${player.defenseRating}\n\n` +
            equippedText + '\n' +
            inventoryText + '\n' +
            abilitiesText + '\n' +
            spellsText
        );
    }

    updateDebugInfo() {
        if (!this.debugMode) return;

        const visibleElements = this.children.list.filter(child => child.visible).length;
        const totalElements = this.children.list.length;

        this.debugText.setText(
            `Debug Mode: ON\n` +
            `Player Position: (${this.player.x}, ${this.player.y})\n` +
            `Visible Elements: ${visibleElements}/${totalElements}\n` +
            `Monsters: ${this.monsters.length}\n` +
            `Layer Visibility: ${this.layerVisibility.map((v, i) => `${this.layerNames[i]}: ${v}`).join(', ')}`
        );
    }

    testRendering() {
        console.log("Testing rendering");
        // Add a red rectangle
        const rect = this.add.rectangle(400, 300, 100, 100, 0xff0000);
        this.addToLayer(rect, 6);

        // Add some text
        const text = this.add.text(400, 200, 'Test Rendering', { 
            font: '32px Arial', 
            fill: '#00ff00' 
        });
        text.setOrigin(0.5);
        this.addToLayer(text, 6);

        console.log("Test rendering objects added");
    }

    createLayerToggles() {
        const toggleBox = this.add.rectangle(1000, 300, 180, 200, 0x333333);
        this.addToLayer(toggleBox, 6);

        const title = this.add.text(920, 210, 'Layer Visibility', { font: '18px Arial', fill: '#ffffff' });
        this.addToLayer(title, 6);

        this.layerCheckboxes = [];

        for (let i = 0; i < this.layers.length; i++) {
            const y = 240 + i * 30;
            const checkbox = this.add.rectangle(930, y, 20, 20, 0xffffff);
            this.addToLayer(checkbox, 6);

            const label = this.add.text(960, y - 10, this.layerNames[i], { font: '16px Arial', fill: '#ffffff' });
            this.addToLayer(label, 6);

            checkbox.setInteractive();
            checkbox.on('pointerdown', () => {
                this.layerVisibility[i] = !this.layerVisibility[i];
                this.layers[i].setVisible(this.layerVisibility[i]);
                checkbox.fillColor = this.layerVisibility[i] ? 0x00ff00 : 0xff0000;
            });

            // Set initial state
            checkbox.fillColor = this.layerVisibility[i] ? 0x00ff00 : 0xff0000;
            this.layerCheckboxes.push(checkbox);
        }
    }

    updateLayerToggles() {
        for (let i = 0; i < this.layers.length; i++) {
            this.layerCheckboxes[i].fillColor = this.layerVisibility[i] ? 0x00ff00 : 0xff0000;
        }
    }

    updateLineOfSight() {
        if (!this.player) return;

        // Clear previous line of sight and light
        if (this.lineOfSightGraphics) {
            this.lineOfSightGraphics.clear();
        } else {
            this.lineOfSightGraphics = this.add.graphics();
            this.addToLayer(this.lineOfSightGraphics, 3); // Add to Lighting layer
        }

        const playerX = this.player.x;
        const playerY = this.player.y;

        // Combine player's light source with wall torches
        const lightSources = [this.player.lightSource, ...this.torches];

        for (let y = 0; y < this.mapHeight; y++) {
            for (let x = 0; x < this.mapWidth; x++) {
                if (this.hasLineOfSight(playerX, playerY, x, y)) {
                    let maxIntensity = 0;

                    // Check all light sources
                    for (const lightSource of lightSources) {
                        const dx = x - lightSource.x;
                        const dy = y - lightSource.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= lightSource.radius) {
                            // Calculate light intensity based on distance
                            const intensity = 1 - (distance / lightSource.radius);
                            maxIntensity = Math.max(maxIntensity, intensity);
                        }
                    }

                    if (maxIntensity > 0) {
                        const alpha = 0.3 * maxIntensity;
                        // Apply yellow light where line of sight and any light source radius overlap
                        this.lineOfSightGraphics.fillStyle(0xffff00, alpha);
                        this.lineOfSightGraphics.fillRect(x * 20, y * 20, 20, 20);
                    }
                }
            }
        }
    }

    hasLineOfSight(x1, y1, x2, y2) {
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const sx = x1 < x2 ? 1 : -1;
        const sy = y1 < y2 ? 1 : -1;
        let err = dx - dy;

        while (true) {
            if (x1 === x2 && y1 === y2) return true;
            if (this.map[y1][x1] === '#') return false;

            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x1 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y1 += sy;
            }
        }
    }
}

const config = {
    type: Phaser.AUTO,
    width: 1100,
    height: 600,
    scene: GameScene,
    parent: 'renderDiv',
    pixelArt: true,
    backgroundColor: '#000000',
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    }
};

window.phaserGame = new Phaser.Game(config);

// Add error logging
window.onerror =

 function(message, source, lineno, colno, error) {
    console.error('An error occurred:', message, 'at', source, 'line', lineno);
    return false;
};